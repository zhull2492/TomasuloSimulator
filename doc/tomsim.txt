# Tomasulo Simulator

CS2410 Project 2

C++ Implementation of the Tomasulo's Algorithm

This program works as two executable files. The first is the xsim progrmam This program produces an instruction trace of a program. See the XSimulator repository for details 
on the input file format. The output is a trace of the program. The output generated by
xsim is the input used for the tomsim executable. The tomsim executable takes a
configuration file and outputs a statistics file.

Requirements:
	This project requires the -ljsoncpp library

To Compile:
	The Makefile provided will compile the program using 'make'

To Execute:
	./xsim [input_file] [output_trace]
	./tomsim [output_trace] [configuration_file] [output_statistics]

The input file is a list of encoded instructions in HEX with one instruction 
per line. Comments are indicated by a # at the start of the line. All programs must
end with a HALT instruction. For more details, see XSimulator Repo.

The configuration file is a JSON file. It allows the latency (in clock cycles) of 
the functional units to be configured. The configurable functional units are INTEGER
MULTIPLY DIVIDE STORE and LOAD. The default latency is 1 clock cycle. It also allows
the number of functional units to be set and the number of reservation stations per
functional unit type.

EX:	{"integer":
		{"number":1,
		 "resnumber":3,
		 "latency":4},
	 "load":
		{"number":1,
		 "resnumber":2,
		 "latency":2}
	}

The output file is a JSON file. It lists statistics from the program including the
total number of clock cycles, total number of pipeline stalls, number of register
reads, and the number of instructions executed in each Functional Unit.

Explanation of Functional Unit Types:

	**INTEGER**
	 1) ADD
	 2) SUB
	 3) AND
	 4) NOR
	 5) LIZ
	 6) LIS
	 7) LUI
	 8) HALT
	 9) PUT

	**DIVIDER**
	10) DIV
	11) MOD
	12) EXP

	**MULTIPLIER**
	13) MUL

	**LOAD**
	14) LW

	**STORE**
	15) SW


PIPELINE INFORMATION:
	The tomsim program models a 4-stage pipeline. Each stage is discussed below.

	ISSUE:
		Instructions proceed in-order through Issue and Read Operand. If there
		is no reservation station available, the pipeline stalls until one 
		becomes available for that type of instruction. If a reservation
		station is availabe, the reservation station is allocated to that
		instruction.

	READ OPERAND:
		After issues, the instruction moves to Read Operand. The instruction reads any
		available source operands from the register file and renames unavailable source
		registers based on the renamed register tags and it renames the destination register.
		When operands are not available, the instruction waits in Read Operand until all
		source operands are available. Instructions may pass each other in this stage

	EXECUTE:
		When all operands are available, the instruction waits for a functional unit to
		become available. Once a functional unit is available, the instruction begins to
		execute for the specified number of cycles defined in the configuration file

	WRITE REGISTER:
		Once execution finishes, the result is broadcast to all waiting instructions in
		Read Operand. Multiple instructions may write on the same clock cycle.

NOTES:

The program must end in a HALT instruction
There are no jumps or branches
There are no structural hazards at the CDB
Instructions are issued in order with out of order commit
For an execution latency of 1 cycle, an instruction will pass through the pipeline in 4 clock cycles
    in the ideal case
